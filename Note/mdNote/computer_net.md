# 计算机网络

主要是小林coding图解网络里的内容

[大佬博客](https://www.cnblogs.com/zhangyinhua/tag/TCP%2FIP%E8%AF%A6%E8%A7%A3/)

## 1.网络模型

### [TCP/IP 模型](https://www.cnblogs.com/zhangyinhua/p/7617027.html)

OSI模型与TCP/IP模型

![img](assets/tcpAndOSI.png)

TCP/IP参考模型分为四个层次：**应用层、传输层、网络互连层和主机到网络层。**

## 2.应用层

### HTTP协议

#### HTTP状态码

*1xx*

1xx 类状态码属于**提示信息**，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。

*2xx*

2xx 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

「**200 OK**」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body数据。

「**204 No Content**」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。「**206 Partial Content**」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。

*3xx*

3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 新发送请求获取资源，也就是**重定向**。

「**301 Moved Permanently**」表示永久定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。

「**302 Found**」表示临时定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。

301 和 302 都会在响应头⾥使⽤**字段 Location ，指明后续要跳转的 URL，浏览器会⾃动定向新的 URL。** 

「**304 Not Modified**」不具有跳转的含义，表示资源未修改，定向已存在的缓冲⽂件，也称缓存定向，⽤于缓存控制。

*4xx*

4xx 类状态码表示客户端发送的**报⽂有误**，服务器⽆法处理，也就是错误码的含义。

「**400 Bad Request**」表示客户端请求的报⽂有错误，但只是个笼统的错误。

「**403 Forbidden**」表示服务器禁⽌访问资源，并不是客户端的请求出错。

「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

*5xx*

5xx 类状态码表示客户端请求报⽂正确，但是**服务器处理时内部发⽣了错误**，属于服务器端的错误码。

「**500 Internal Server Error**」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。

「**501 Not Implemented**」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。

「**502 Bad Gateway**」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器

发⽣了错误。

「**503 Service Unavailable**」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后试”的意思

#### HTTP常见字段

- *Host* 字段

  客户端发送请求时，⽤来指定服务器的域名

- *Content-Length* 字段

  服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。

- Connection 字段

  最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为`Keep-Alive` 。

- Content-Type Accept 字段

  ⽤于服务器回应时，告诉客户端，本次数据是什么格式。

  用于告诉服务器为接收什么数据格式

- Content-Encoding 字段

  说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式

  `Accept-Encoding` 字段说明⾃⼰可以接受哪些压缩⽅法。

#### GET 与 POST

​	1. Get ⽅法的含义是请求**从服务器获取资源**，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。

​		POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。

​	2. **GET** **⽅法就是安全且幂等的**

​		**POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多

个资源，所以**不是幂等**的。

>  在HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。
>
> 所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。

#### HTTP 特性

优点

​	*1.* 简单

​		HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，**易于理解**，降低了学习和使⽤的⻔槛。

​	*2.* 灵活和易于扩展

​		HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员**⾃定****义和扩充**。

​		 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的QUIC。

​	*3.* 应⽤⼴泛和跨平台

​		互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应⽤**⽚地开花**，同时天然具有**跨平台**的优越性。

缺点

​	*1.* ⽆状态双刃剑

​		⽆状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。

​		⽆状态的**坏处**，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。

> 对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ **Cookie** 技术。Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态

​	*2.* 明⽂传输双刃剑

​		明⽂意味着在传输过程中的信息，是可⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查看，为我们调试⼯作带了极⼤的便利性。但是这正是这样，HTTP 的所有信息都暴露在了光天化⽇下，相当于**信息裸奔**。在传输的漫⻓的过程中，信息的内容都毫⽆隐私可⾔，很容易就能被窃取，如果⾥⾯有你的账号密码信息，那**你号没了**。

​	*3.* 不安全

​		HTTP ⽐较严重的缺点就是不安全：

​			通信使⽤明⽂（不加密），内容可能会被窃听。

​			不验证通信⽅的身份，因此有可能遭遇伪装。

​			⽆法证明报⽂的完整性，所以有可能已遭篡改。

#### HTTP/1.1 的性能

1. 长连接

   持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。这种⽅式的好处在于减少了TCP 连接的重复建⽴和断开所造成的额外开销，减轻了服务器端的负载。

2. 管道⽹络传输

   同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以**减少整体的响应时间。**

3. 队头阻塞

   当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据，这也就是「**队头阻塞**」。

#### HTTP 与 HTTPS

区别：

1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。

2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。

3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。

4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

SSL/TLS 协议，解决了以下的问题：

- **信息加密**：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。

- **校验机制**：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。

- **身份证书**：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。

解决方式：

1. 混合加密：

   HTTPS 采⽤的是**对称加密**和**⾮对称加密**结合的「混合加密」⽅式：

   - 在通信建⽴前采⽤**⾮对称加密**的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。

   - 在通信过程中全部使⽤**对称加密**的「会话秘钥」的⽅式加密明⽂数据。

   采⽤「混合加密」的⽅式的原因：

   - **对称加密**只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。

   - **⾮对称加密**使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。

2. 摘要算法：

   **摘要算法**⽤来实现**完整性**，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险。

3. 数字证书：

   借助第三⽅权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

![image-20220827153456685](assets/image-20220827153456685.png)

#### SSL/TLS协议流程

![image-20220827153638937](assets/image-20220827153638937.png)

#### HTTP/1.1、HTTP/2、HTTP/3 演变

HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：

- 使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。

- ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：

1. 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；

2. 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；

3. 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；
4. 没有请求优先级控制；
5. 请求只能从客户端开始，服务器只能被动响应。

 HTTP/2 相⽐ HTTP/1.1 性能上的改进：

1. 头部压缩：

   HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你**消除重复的部分**。这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就**提⾼速度**了。

2.  ⼆进制格式：

   HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了**⼆进制格式**，头信息和数据体都是⼆进制，并且统称为帧（frame）：**头信息帧和数据帧**。

3. 数据流：

   HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

   每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数

   客户端还可以**指定数据流的优先级**。优先级⾼的请求，服务器就先响应该请求

4. 多路复⽤

   HTTP/2 是可以在**⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应**。移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，**降低了延迟，⼤幅度提⾼了连接的利⽤率**。

5. 服务器推送

   HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。

   举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送（Server Push，也叫 Cache Push）。

## 3. 传输层

### **TCP简介**

TCP 是**⾯向连接的、可靠的、基于字节流**的传输层通信协议

- **⾯向连接**：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是⽆法做到的；
- **可靠的**：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；

- **字节流**：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃。

### [**TCP** **报文详解**](https://juejin.cn/post/6958440414336516110)

![image-20220827163241426](assets/image-20220827163241426.png)

**首部长度**：TCP被封装在IP数据报中，在没有选项的前提下，TCP首部长20字节（最长可以到60字节）。

**端口号：**源端和目的端的端囗号,用于寻找发端和收端应用进程。

**序列号**：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。**⽤来解决⽹络包乱序问题。**

**确认应答号**：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**⽤来解决不丢包的问题。**

**窗口大小:** 用于表示滑动窗口大小，窗口大小最大为65535(2^16-1)字节

**紧急指针:**是一个正的偏移量,和序号字段中的值相加表示紧急数据最后一个字节的序号。

**控制位：**

- *URG*：紧急指针( urgent pointer)有效标志位。它使一端可以告诉另一端有些具有某种方式的“ 紧急数据” 已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流中,由接收方决定如何处理。

- *ACK*：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。

- *RST*：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
  - RST产生和使用场景：
    - 目的端口无监听。当连接请求到达时,目的端口没有进程正在监听，TCP会产生一个复位报文。（在UDP中，则产生一个ICMP端口不可达的信息）
    - 异常终止链接。可以通过发送个复位报文段而不是FIN来中途释放一个连接，这种行为称为异常释放( abortive release)。

- *SYN*：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。

- *FIN*：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的

- 主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

**选项：**

![image.png](assets/304ac9174064459cbb60214820fce5ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

### UDP报文头

![image-20220827183654973](assets/image-20220827183654973.png)

### TCP与UDP比较

1. 连接

​		TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。

​		UDP 是不需要连接，即刻传输数据。

2. 服务对象

​		TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。

​		UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信

3. 可靠性

​		TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。	

​		UDP 是尽最⼤努⼒交付，不保证可靠交付数据。

4. 拥塞控制、流ᰁ控制

​		TCP 有拥塞控制和流ᰁ控制机制，保证数据传输的安全性。UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。

5. ⾸部开销

​		TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的。

​		UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。

6. 传输⽅式

​		TCP 是流式传输，没有边界，但保证顺序和可靠。

​		UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。

7. 分⽚不同

​		TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。

​		UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。

### 面向字节与面向报文

**面向报文的传输方式**是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。**UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界**。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。 

**面向字节流**的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

### TCP连接建立 三次握手

![image-20220828094335783](assets/image-20220828094335783.png)

第一个报文

![image-20220828094511587](assets/image-20220828094511587.png)

第二个报文

![image-20220828094648143](assets/image-20220828094648143.png)

> 为什么ACK需要加1 应为之前发送的SYN报文需要被确认

第三个报文

![image-20220828094930203](assets/image-20220828094930203.png)

> **第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的**

为什么需要三次握手？

1. 避免历史连接

   三次握⼿的**⾸要原因是为了防⽌旧的重复连接初始化造成混乱**

   [RFC原文](https://www.rfc-editor.org/rfc/rfc793#section-3.4)

   > *The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion. To deal with this, a special control message, reset, has been devised.*

   ![image-20220828100357165](assets/image-20220828100357165.png)

   **如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此重置连接**

2. 同步双⽅初始序列号

   序列号的作用：

   - 接收⽅可以去除重复的数据；
   - 接收⽅可以根据数据包的序列号按序接收；
   - 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的

小结：

TCP 建⽴连接时，通过三次握⼿**能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序**

**列号**。序列号能够保证数据包不重复、不丢弃和按序传输。

不使⽤「两次握⼿」和「四次握⼿」的原因：

- 「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；
- 「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数

### TCP断开连接

![image-20220828164422638](assets/image-20220828164422638.png)

为什么挥⼿需要四次？

!!! 挥手不一定需要四次，当服务端没有数据需要发送时，ACK和FIN可以合并成为一个报文。

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

- 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。

为什么需要TIME_WAIT 状态？

- 防⽌具有相同「四元组」的「旧」数据包被收到；

- 保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭；

The book <<UNIX Network Programming(Volume1,3rd)>> give an answer:

> There are two reasons for the TIME_WAIT state:
>
> 1. To implement TCP's full-duplex connection termination reliably //实现全双工的TCO连接稳定的终止
> 2. To allow old duplicate segments to expire in the network // 旧报文在网络中消亡

### 重传

**超时重传**

RTT （Round-Trip Time 往返时延）

RTO （Retransmission Timeout 超时重传时间）

RTO对TCP的影响

> 当超时时间 **RTO** **较⼤**时，重发就慢，丢了⽼半天才重发，没有效率，性能差；
>
> 当超时时间 **RTO** **较⼩**时，会导致可能并没有丢就重发，于是重发的就快，会增加⽹络拥塞，导致更多的超
>
> 时，更多的超时导致更多的重发。

**快速重传**

当收到3个重复的ACK时，TCP会在超时前重传数据包。（但是重传是重传所有还是单个数据包根据实现都是有可能的）

**SACK选项**

这种⽅式需要在 TCP 头部「选项」字段⾥加⼀个 SACK 的东⻄，它**可以将缓存的地图发送给发送⽅**，这样发送

⽅就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

![image-20220828200133006](assets/image-20220828200133006.png)

**DSACK**

![image-20220828200359238](assets/image-20220828200359238.png)

![image-20220828200409525](assets/image-20220828200409525.png)

D-SACK 有这么⼏个好处：

1. 可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了;

2. 可以知道是不是「发送⽅」的数据包被⽹络延迟了;

3. 可以知道⽹络中是不是把「发送⽅」的数据包给复制了;

### 滑动窗口

窗口大小：

​	**window size这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会	导致接收端处理不过来。**

